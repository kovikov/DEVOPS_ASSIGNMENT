name: CD - Deploy to EC2 using AWS CLI

# Trigger this workflow after the CI workflow succeeds
on:
  workflow_run:
    workflows: ["CI - Build and Push Docker Image"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    # Only deploy if the CI workflow actually succeeded
    if: ${{ github.event.workflow_run.conclusion == 'success' }}

    steps:
      # ──────────────────────────────────────────────────────
      # STEP 1: Configure AWS CLI credentials
      # This allows us to query EC2 instances without hardcoding IPs
      # ──────────────────────────────────────────────────────
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # ──────────────────────────────────────────────────────
      # STEP 1.5: Verify AWS authentication context
      # ──────────────────────────────────────────────────────
      - name: Verify AWS identity
        shell: bash
        run: |
          set -e
          if ! aws sts get-caller-identity; then
            echo "::error::AWS authentication failed. Check AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_REGION, and IAM user status."
            exit 1
          fi

      # ──────────────────────────────────────────────────────
      # STEP 2: Fetch EC2 instance IPs using AWS CLI and tags
      # This is the KEY difference from the original - no hardcoded IPs!
      # Query running instances tagged with Environment=production
      # and get their public IPs
      # ──────────────────────────────────────────────────────
      - name: Get EC2 instances using AWS CLI
        id: get_instances
        shell: bash
        run: |
          set -e

          # Query EC2 instances with specific tags
          # Adjust the filter to match your EC2 instances' tags
          # Example: Name=tag:Environment,Values=production
          PUBLIC_INSTANCES=$(aws ec2 describe-instances \
            --filters "Name=tag:${{ secrets.EC2_TAG_KEY }},Values=${{ secrets.EC2_TAG_VALUE }}" \
                      "Name=instance-state-name,Values=running" \
            --query 'Reservations[*].Instances[*].PublicIpAddress' \
            --output text)

          PRIVATE_INSTANCES=$(aws ec2 describe-instances \
            --filters "Name=tag:${{ secrets.EC2_TAG_KEY }},Values=${{ secrets.EC2_TAG_VALUE }}" \
                      "Name=instance-state-name,Values=running" \
            --query 'Reservations[*].Instances[*].PrivateIpAddress' \
            --output text)

          # Normalize tabs/newlines to a clean, single-line space-separated list
          PUBLIC_INSTANCES=$(echo "$PUBLIC_INSTANCES" | tr '\t\n' ' ' | xargs || true)
          PRIVATE_INSTANCES=$(echo "$PRIVATE_INSTANCES" | tr '\t\n' ' ' | xargs || true)

          # Convert space-separated IPs into an array (skip empty values)
          IP_ARRAY=()
          for ip in $PUBLIC_INSTANCES; do
            if [ -n "$ip" ]; then
              IP_ARRAY+=("$ip")
            fi
          done

          echo "Found ${#IP_ARRAY[@]} instances with tags:"
          for ip in "${IP_ARRAY[@]}"; do
            echo "  - $ip"
          done

          # Store IPs for use in later steps
          echo "instance_ips=${PUBLIC_INSTANCES}" >> "$GITHUB_OUTPUT"
          echo "instance_count=${#IP_ARRAY[@]}" >> $GITHUB_OUTPUT

          # Validate we found instances
          if [ ${#IP_ARRAY[@]} -eq 0 ]; then
            if [ -n "$PRIVATE_INSTANCES" ]; then
              echo "❌ Tagged running instances were found, but they have no PUBLIC IPs."
              echo "Private IPs found: $PRIVATE_INSTANCES"
              echo "Use public EC2/EIP for SSH from GitHub Actions, or switch deployment to SSM/self-hosted runner."
              echo "::error::Tagged instances found but no public IPs. GitHub-hosted runner cannot SSH to private-only instances."
              exit 1
            fi

            echo "❌ No running instances found with the specified tags!"
            echo "Tag Key: ${{ secrets.EC2_TAG_KEY }}"
            echo "Tag Value: ${{ secrets.EC2_TAG_VALUE }}"
            echo "::error::No running EC2 instances match tag ${{ secrets.EC2_TAG_KEY }}=${{ secrets.EC2_TAG_VALUE }} in region ${{ secrets.AWS_REGION }}."
            exit 1
          fi

      # ──────────────────────────────────────────────────────
      # STEP 3: Set up SSH key from GitHub Secrets
      # ──────────────────────────────────────────────────────
      - name: Set up SSH key
        shell: bash
        run: |
          set -e

          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/deploy_key.pem
          chmod 600 ~/.ssh/deploy_key.pem
          echo "StrictHostKeyChecking no" >> ~/.ssh/config
          echo "UserKnownHostsFile /dev/null" >> ~/.ssh/config
          chmod 600 ~/.ssh/config

      # ──────────────────────────────────────────────────────
      # STEP 4: Preflight check for SSH + Docker availability
      # Fail fast with clear diagnostics before deployment
      # ──────────────────────────────────────────────────────
      - name: Preflight connectivity checks
        shell: bash
        run: |
          set -e

          INSTANCES="${{ steps.get_instances.outputs.instance_ips }}"
          IP_ARRAY=()
          for ip in $INSTANCES; do
            if [ -n "$ip" ]; then
              IP_ARRAY+=("$ip")
            fi
          done

          READY=0
          FAILED=0

          for EC2_IP in "${IP_ARRAY[@]}"; do
            echo "Preflight checking: $EC2_IP"

            if ssh -T -i ~/.ssh/deploy_key.pem \
              -o StrictHostKeyChecking=no \
              -o ConnectTimeout=10 \
              ${{ secrets.EC2_USER }}@$EC2_IP \
              "command -v docker >/dev/null && sudo docker --version >/dev/null"
            then
              echo "✅ SSH and Docker OK on $EC2_IP"
              ((READY+=1))
            else
              echo "❌ SSH or Docker check failed on $EC2_IP"
              ((FAILED+=1))
            fi
          done

          echo "Preflight summary: $READY ready, $FAILED failed"
          if [ $FAILED -gt 0 ]; then
            echo "::error::SSH/Docker preflight failed on one or more instances. Check EC2_USER, EC2_SSH_KEY, SG port 22, and Docker service."
            exit 1
          fi

      # ──────────────────────────────────────────────────────
      # STEP 5: Deploy to all discovered instances
      # Dynamically iterate through all instances found by AWS CLI
      # ──────────────────────────────────────────────────────
      - name: Deploy to all EC2 instances
        shell: bash
        run: |
          set -e

          # Get the IPs from the previous step
          INSTANCES="${{ steps.get_instances.outputs.instance_ips }}"

          # Convert to array (skip empty values)
          IP_ARRAY=()
          for ip in $INSTANCES; do
            if [ -n "$ip" ]; then
              IP_ARRAY+=("$ip")
            fi
          done

          # Counter for tracking deployments
          DEPLOYED=0
          FAILED=0

          # Deploy to each instance
          for EC2_IP in "${IP_ARRAY[@]}"; do
            if [ -z "$EC2_IP" ]; then
              continue
            fi

            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "Deploying to: $EC2_IP"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

            # SSH into instance and deploy
            if ssh -T -i ~/.ssh/deploy_key.pem \
              -o StrictHostKeyChecking=no \
              -o ConnectTimeout=10 \
              ${{ secrets.EC2_USER }}@$EC2_IP \
              "sudo docker pull ${{ secrets.DOCKERHUB_USERNAME }}/load-balancer-app:latest; \
               sudo docker stop load-balancer-app || true; \
               sudo docker rm load-balancer-app || true; \
               sudo docker run --name load-balancer-app -d -p 80:80 ${{ secrets.DOCKERHUB_USERNAME }}/load-balancer-app:latest; \
               echo '✅ Container started'"
            then
              ((DEPLOYED+=1))
            else
              ((FAILED+=1))
              echo "❌ Deployment failed for $EC2_IP"
            fi

            # Wait before next deployment
            sleep 5
          done

          # Print summary
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "Deployment Summary"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "✅ Successful: $DEPLOYED"
          echo "❌ Failed: $FAILED"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

          # Fail if any deployments failed
          if [ $FAILED -gt 0 ]; then
            echo "::error::Deployment command failed on one or more instances. Check remote Docker logs and permissions."
            exit 1
          fi

      # ──────────────────────────────────────────────────────
      # STEP 6: Health check all deployed instances
      # Verify that the application is running on each server
      # ──────────────────────────────────────────────────────
      - name: Health check all instances
        shell: bash
        run: |
          set -e

          INSTANCES="${{ steps.get_instances.outputs.instance_ips }}"
          IP_ARRAY=()
          for ip in $INSTANCES; do
            if [ -n "$ip" ]; then
              IP_ARRAY+=("$ip")
            fi
          done

          HEALTHY=0
          UNHEALTHY=0

          for EC2_IP in "${IP_ARRAY[@]}"; do
            if [ -z "$EC2_IP" ]; then
              continue
            fi

            echo "Health checking: $EC2_IP"

            # Wait for container to start
            sleep 15

            # Perform health check
            STATUS=$(curl -sS -o /dev/null -w "%{http_code}" \
              --max-time 5 \
              http://$EC2_IP/health || true)

            if [ "$STATUS" = "200" ]; then
              echo "✅ $EC2_IP is healthy (Status: $STATUS)"
              ((HEALTHY+=1))
            else
              echo "❌ $EC2_IP health check failed (Status: $STATUS)"
              ((UNHEALTHY+=1))
            fi
          done

          echo ""
          echo "Health Check Summary: $HEALTHY healthy, $UNHEALTHY unhealthy"

          if [ $UNHEALTHY -gt 0 ]; then
            echo "::error::Health check failed. Ensure SG allows port 80 and app responds on /health with HTTP 200."
            exit 1
          fi

      # ──────────────────────────────────────────────────────
      # STEP 7: Post-deployment verification
      # Retrieve application info from all instances
      # ──────────────────────────────────────────────────────
      - name: Verify deployments
        shell: bash
        run: |
          set -e

          INSTANCES="${{ steps.get_instances.outputs.instance_ips }}"
          IP_ARRAY=()
          for ip in $INSTANCES; do
            if [ -n "$ip" ]; then
              IP_ARRAY+=("$ip")
            fi
          done

          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "Deployment Verification"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

          for EC2_IP in "${IP_ARRAY[@]}"; do
            if [ -z "$EC2_IP" ]; then
              continue
            fi

            echo ""
            echo "Server: $EC2_IP"
            echo "---"
            curl -s http://$EC2_IP/ | jq '.' 2>/dev/null || \
              curl -s http://$EC2_IP/

            echo ""
          done

          echo ""
          echo "✅ All deployments complete!"
