name: CD - Deploy to EC2 using AWS CLI

# Trigger this workflow after the CI workflow succeeds
on:
  workflow_run:
    workflows: ["CI - Build and Push Docker Image"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
      AWS_REGION: ${{ secrets.AWS_REGION }}

    # Only deploy if the CI workflow actually succeeded
    if: ${{ github.event.workflow_run.conclusion == 'success' }}

    steps:
      # ──────────────────────────────────────────────────────
      # STEP 1: Verify required runtime environment
      # ──────────────────────────────────────────────────────
      - name: Verify runtime prerequisites
        shell: bash
        run: |
          set -e
          command -v aws >/dev/null || { echo "::error::AWS CLI not found on runner."; exit 1; }
          aws --version
          if [ -z "${AWS_ACCESS_KEY_ID}" ] || [ -z "${AWS_SECRET_ACCESS_KEY}" ] || [ -z "${AWS_REGION}" ]; then
            echo "::error::Missing one or more AWS secrets: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_REGION"
            exit 1
          fi

      # ──────────────────────────────────────────────────────
      # STEP 1.5: Verify AWS authentication context
      # ──────────────────────────────────────────────────────
      - name: Verify AWS identity
        shell: bash
        run: |
          set -e
          if ! aws sts get-caller-identity; then
            echo "::error::AWS authentication failed. Check AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_REGION, and IAM user status."
            exit 1
          fi

      # ──────────────────────────────────────────────────────
      # STEP 2: Fetch EC2 instance IPs using AWS CLI and tags
      # This is the KEY difference from the original - no hardcoded IPs!
      # Query running instances tagged with Environment=production
      # and get their public IPs
      # ──────────────────────────────────────────────────────
      - name: Get EC2 instances using AWS CLI
        id: get_instances
        shell: bash
        run: |
          set -e

          TARGET_INSTANCE_ID="${{ secrets.EC2_INSTANCE_ID }}"

          if [ -z "$TARGET_INSTANCE_ID" ]; then
            echo "::error::Missing required secret EC2_INSTANCE_ID. Add a running EC2 instance ID (example: i-0123456789abcdef0)."
            exit 1
          fi

          echo "Using fixed instance override via EC2_INSTANCE_ID"
          PUBLIC_INSTANCES=$(aws ec2 describe-instances \
            --instance-ids "$TARGET_INSTANCE_ID" \
            --filters "Name=instance-state-name,Values=running" \
            --query 'Reservations[*].Instances[*].PublicIpAddress' \
            --output text)

          PRIVATE_INSTANCES=$(aws ec2 describe-instances \
            --instance-ids "$TARGET_INSTANCE_ID" \
            --filters "Name=instance-state-name,Values=running" \
            --query 'Reservations[*].Instances[*].PrivateIpAddress' \
            --output text)

          # Normalize tabs/newlines to a clean, single-line space-separated list
          PUBLIC_INSTANCES=$(echo "$PUBLIC_INSTANCES" | tr '\t\n' ' ' | xargs || true)
          PRIVATE_INSTANCES=$(echo "$PRIVATE_INSTANCES" | tr '\t\n' ' ' | xargs || true)

          # Convert space-separated IPs into an array (skip empty values)
          IP_ARRAY=()
          for ip in $PUBLIC_INSTANCES; do
            if [ -n "$ip" ]; then
              IP_ARRAY+=("$ip")
            fi
          done

          echo "Found ${#IP_ARRAY[@]} instances with tags:"
          for ip in "${IP_ARRAY[@]}"; do
            echo "  - $ip"
          done

          # Store IPs for use in later steps
          echo "instance_ips=${PUBLIC_INSTANCES}" >> "$GITHUB_OUTPUT"
          echo "instance_count=${#IP_ARRAY[@]}" >> $GITHUB_OUTPUT

          # Validate we found instances
          if [ ${#IP_ARRAY[@]} -eq 0 ]; then
            if [ -n "$PRIVATE_INSTANCES" ]; then
              echo "❌ Running instance was found, but it has no PUBLIC IP."
              echo "Private IPs found: $PRIVATE_INSTANCES"
              echo "Use public EC2/EIP for SSH from GitHub Actions, or switch deployment to SSM/self-hosted runner."
              echo "::error::Target instance has no public IP. GitHub-hosted runner cannot SSH to private-only instances."
              exit 1
            fi

            echo "❌ EC2_INSTANCE_ID is set but no running instance was found for that ID."
            echo "::error::No running instance found for EC2_INSTANCE_ID=$TARGET_INSTANCE_ID in region ${{ secrets.AWS_REGION }}."
            exit 1
          fi

      # ──────────────────────────────────────────────────────
      # STEP 3: Set up SSH key from GitHub Secrets
      # ──────────────────────────────────────────────────────
      - name: Set up SSH key
        shell: bash
        run: |
          set -e

          EC2_USER_VALUE="${{ secrets.EC2_USER }}"
          if [ -z "$EC2_USER_VALUE" ]; then
            EC2_USER_VALUE="ec2-user"
            echo "::warning::EC2_USER secret missing; defaulting to ec2-user."
          fi

          if ! [[ "$EC2_USER_VALUE" =~ ^[a-z_][a-z0-9_-]*$ ]]; then
            echo "::error::EC2_USER appears invalid. Use a Linux username only (for example: ec2-user or ubuntu)."
            exit 1
          fi

          mkdir -p ~/.ssh
          KEY_CONTENT_B64="${{ secrets.EC2_SSH_KEY_B64 }}"

          if [ -z "$KEY_CONTENT_B64" ]; then
            echo "::error::Missing required secret EC2_SSH_KEY_B64. Add base64 of your my-devops-key.pem file."
            exit 1
          fi

          echo "Using EC2_SSH_KEY_B64 secret"
          if ! printf "%s" "$KEY_CONTENT_B64" | tr -d '\r\n ' | base64 -d > ~/.ssh/deploy_key.pem; then
            echo "::error::EC2_SSH_KEY_B64 is not valid base64. Regenerate it from the .pem file and paste again."
            exit 1
          fi

          chmod 600 ~/.ssh/deploy_key.pem

          if ! ssh-keygen -y -f ~/.ssh/deploy_key.pem >/dev/null 2>&1; then
            echo "::error::Decoded EC2_SSH_KEY_B64 is not a valid private key. Ensure you base64-encoded the exact my-devops-key.pem file."
            exit 1
          fi

          echo "StrictHostKeyChecking no" >> ~/.ssh/config
          echo "UserKnownHostsFile /dev/null" >> ~/.ssh/config
          chmod 600 ~/.ssh/config

      # ──────────────────────────────────────────────────────
      # STEP 4: Preflight check for SSH + Docker availability
      # Fail fast with clear diagnostics before deployment
      # ──────────────────────────────────────────────────────
      - name: Preflight connectivity checks
        shell: bash
        run: |
          set -e

          EC2_USER_VALUE="${{ secrets.EC2_USER }}"
          if [ -z "$EC2_USER_VALUE" ]; then
            EC2_USER_VALUE="ec2-user"
            echo "::warning::EC2_USER secret missing; defaulting to ec2-user."
          fi

          INSTANCES="${{ steps.get_instances.outputs.instance_ips }}"
          IP_ARRAY=()
          for ip in $INSTANCES; do
            if [ -n "$ip" ]; then
              IP_ARRAY+=("$ip")
            fi
          done

          READY=0
          FAILED=0

          for EC2_IP in "${IP_ARRAY[@]}"; do
            echo "Preflight checking: $EC2_IP"
            TARGET_HOST="${EC2_USER_VALUE}@${EC2_IP}"

            if ssh -T -i ~/.ssh/deploy_key.pem \
              -o StrictHostKeyChecking=no \
              -o ConnectTimeout=10 \
              "$TARGET_HOST" \
              "command -v docker >/dev/null && sudo docker --version >/dev/null"
            then
              echo "✅ SSH and Docker OK on $EC2_IP"
              ((READY+=1))
            else
              echo "❌ SSH or Docker check failed on $EC2_IP"
              ((FAILED+=1))
            fi
          done

          echo "Preflight summary: $READY ready, $FAILED failed"
          if [ $FAILED -gt 0 ]; then
            echo "::error::SSH/Docker preflight failed on one or more instances. Check EC2_USER, EC2_SSH_KEY, SG port 22, and Docker service."
            exit 1
          fi

      # ──────────────────────────────────────────────────────
      # STEP 5: Deploy to all discovered instances
      # Dynamically iterate through all instances found by AWS CLI
      # ──────────────────────────────────────────────────────
      - name: Deploy to all EC2 instances
        shell: bash
        run: |
          set -e

          EC2_USER_VALUE="${{ secrets.EC2_USER }}"
          if [ -z "$EC2_USER_VALUE" ]; then
            EC2_USER_VALUE="ec2-user"
            echo "::warning::EC2_USER secret missing; defaulting to ec2-user."
          fi

          # Get the IPs from the previous step
          INSTANCES="${{ steps.get_instances.outputs.instance_ips }}"

          # Convert to array (skip empty values)
          IP_ARRAY=()
          for ip in $INSTANCES; do
            if [ -n "$ip" ]; then
              IP_ARRAY+=("$ip")
            fi
          done

          # Counter for tracking deployments
          DEPLOYED=0
          FAILED=0

          # Deploy to each instance
          for EC2_IP in "${IP_ARRAY[@]}"; do
            if [ -z "$EC2_IP" ]; then
              continue
            fi

            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "Deploying to: $EC2_IP"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            TARGET_HOST="${EC2_USER_VALUE}@${EC2_IP}"

            # SSH into instance and deploy
            if ssh -T -i ~/.ssh/deploy_key.pem \
              -o StrictHostKeyChecking=no \
              -o ConnectTimeout=10 \
              "$TARGET_HOST" \
              "sudo docker pull ${{ secrets.DOCKERHUB_USERNAME }}/load-balancer-app:latest; \
               sudo docker stop load-balancer-app || true; \
               sudo docker rm load-balancer-app || true; \
               sudo docker run --name load-balancer-app -d -p 80:80 ${{ secrets.DOCKERHUB_USERNAME }}/load-balancer-app:latest; \
               echo '✅ Container started'"
            then
              ((DEPLOYED+=1))
            else
              ((FAILED+=1))
              echo "❌ Deployment failed for $EC2_IP"
            fi

            # Wait before next deployment
            sleep 5
          done

          # Print summary
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "Deployment Summary"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "✅ Successful: $DEPLOYED"
          echo "❌ Failed: $FAILED"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

          # Fail if any deployments failed
          if [ $FAILED -gt 0 ]; then
            echo "::error::Deployment command failed on one or more instances. Check remote Docker logs and permissions."
            exit 1
          fi

      # ──────────────────────────────────────────────────────
      # STEP 6: Health check all deployed instances
      # Verify that the application is running on each server
      # ──────────────────────────────────────────────────────
      - name: Health check all instances
        shell: bash
        run: |
          set -e

          INSTANCES="${{ steps.get_instances.outputs.instance_ips }}"
          IP_ARRAY=()
          for ip in $INSTANCES; do
            if [ -n "$ip" ]; then
              IP_ARRAY+=("$ip")
            fi
          done

          HEALTHY=0
          UNHEALTHY=0

          for EC2_IP in "${IP_ARRAY[@]}"; do
            if [ -z "$EC2_IP" ]; then
              continue
            fi

            echo "Health checking: $EC2_IP"

            # Wait for container to start
            sleep 15

            # Perform health check
            STATUS=$(curl -sS -o /dev/null -w "%{http_code}" \
              --max-time 5 \
              http://$EC2_IP/health || true)

            if [ "$STATUS" = "200" ]; then
              echo "✅ $EC2_IP is healthy (Status: $STATUS)"
              ((HEALTHY+=1))
            else
              echo "❌ $EC2_IP health check failed (Status: $STATUS)"
              ((UNHEALTHY+=1))
            fi
          done

          echo ""
          echo "Health Check Summary: $HEALTHY healthy, $UNHEALTHY unhealthy"

          if [ $UNHEALTHY -gt 0 ]; then
            echo "::error::Health check failed. Ensure SG allows port 80 and app responds on /health with HTTP 200."
            exit 1
          fi

      # ──────────────────────────────────────────────────────
      # STEP 7: Post-deployment verification
      # Retrieve application info from all instances
      # ──────────────────────────────────────────────────────
      - name: Verify deployments
        shell: bash
        run: |
          set -e

          INSTANCES="${{ steps.get_instances.outputs.instance_ips }}"
          IP_ARRAY=()
          for ip in $INSTANCES; do
            if [ -n "$ip" ]; then
              IP_ARRAY+=("$ip")
            fi
          done

          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "Deployment Verification"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

          for EC2_IP in "${IP_ARRAY[@]}"; do
            if [ -z "$EC2_IP" ]; then
              continue
            fi

            echo ""
            echo "Server: $EC2_IP"
            echo "---"
            curl -s http://$EC2_IP/ | jq '.' 2>/dev/null || \
              curl -s http://$EC2_IP/

            echo ""
          done

          echo ""
          echo "✅ All deployments complete!"
